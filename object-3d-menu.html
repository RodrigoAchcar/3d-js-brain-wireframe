<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">		
		<title>Webgl Model Menu with CSS Layout</title>
		<meta name="author" content="funilariadigital">
		<!--<link rel="apple-touch-icon" sizes="180x180" href="./media/img/favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="./media/img/favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="./media/img/favicon/favicon-16x16.png">
		<link rel="manifest" href="./media/img/favicon/site.webmanifest">-->
		<link rel="stylesheet" href="./static/css/layout.css">
	</head>
	<body>
<div id="container"></div>
<div class="invisible">
	<div id="brainR-parietal" class="element">
		<div class="topic">Right Parietal Lobe</div>
		<div class="details">Right Parietal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainR-frontal" class="element">
		<div class="topic">Right Frontal Lobe</div>
		<div class="details">Right Frontal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainR-temporal" class="element">
		<div class="topic">Right Temporal Lobe</div>
		<div class="details">Right Temporal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainR-occipital" class="element">
		<div class="topic">Right Occipital Lobe</div>
		<div class="details">Right Occipital Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainL-parietal" class="element">
		<div class="topic">Left Parietal Lobe</div>
		<div class="details">Left Parietal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainL-frontal" class="element">
		<div class="topic">Left Frontal Lobe</div>
		<div class="details">Left Frontal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainL-temporal" class="element">
		<div class="topic">Left Temporal Lobe</div>
		<div class="details">Left Temporal Lobe - Dynamic mesh area complementary information</div>
	</div>
	<div id="brainL-occipital" class="element">
		<div class="topic">Left Occipital Lobe</div>
		<div class="details">Left Occipital Lobe - Dynamic mesh area complementary information</div>
	</div>
</div>
<script type="importmap">
	{
		"imports": {
			"three": "./static/js/webgl/build/three.module.js",
			"three/addons/": "./static/js/webgl/jsm/"
		}
	}
</script>
<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { Wireframe } from 'three/addons/lines/Wireframe.js';
	import { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
	import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
	const scene  = new THREE.Scene();
	const lineSegments = new THREE.LineSegments();
	let renderer, cssRenderer, raycaster, camera, controls, model, curveSrc, infoBox, line, objectCSS, point, points, lineGeo, lineSpline;
	let xPos, yPos, zPos, headPos, midHeadPos, midTailPos, tailPos;
	headPos = new THREE.Vector3();
	midHeadPos = new THREE.Vector3();
	midTailPos = new THREE.Vector3();
	tailPos = new THREE.Vector3();
	const raycastMeshes = [];
	let intersects, currentIntersected;
	let pointIntersect = new THREE.Vector2( 0, 0);
	let curveView = false;
	let arraySlice = [];
	
	let renderGroup = [];
	
	const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
	const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

	const matLine = new LineMaterial( {
		color: 0x40e0d0,
		linewidth: 3,
		transparent: true,
		opacity: 0.4,
		vertexColors: false,
		dashed: false,
		clipShadows: false,
		alphaToCoverage: true,
		} );
	function setRAF(fps){
		return { fps: fps, fpsD: Math.round( 1000/fps ), currFrame: 0, currT: 0, prevT: 0, fpsInterval: 0, motionCount: 0}
	}	
	init();
	function init() {
		scene.raf = setRAF(30);
		const container = document.getElementById( 'container' );
		buildStage();
		buildHandlers();
		window.addEventListener( 'resize', onWindowResize );
		animate();
	}
	function buildStage(){
		scene.background = new THREE.Color( 0x000000 );
		renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = false;
		renderer.domElement.style.position = 'absolute';
		renderer.domElement.style.top = 0;
		container.appendChild( renderer.domElement );
		cssRenderer = new CSS3DRenderer({ antialias: true, alpha: true });
		cssRenderer.setSize( window.innerWidth, window.innerHeight );
		cssRenderer.domElement.style.position = 'absolute';
		cssRenderer.domElement.style.top = 0;
		container.appendChild( cssRenderer.domElement );
		raycaster = new THREE.Raycaster();
		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
		camera.position.set( -1, 1, 2);
		controls = new OrbitControls( camera, cssRenderer.domElement );
		controls.autoRotate = true;
		controls.autoRotateSpeed = -1;
		controls.rotateSpeed = 0.1;
		controls.target =  new THREE.Vector3( 0, 0.2, 0 );
		controls.maxPolarAngle = 1.76;
		controls.minPolarAngle = 1.3;
		controls.enableDamping = true;
		controls.dampingFactor = 1.2;
	}
	function buildHandlers(){
		const loader = new GLTFLoader();
		let raycastedMesh = new THREE.MeshBasicMaterial( { color: "#000000", visible: false, side: THREE.FrontSide} );
		loader.load( './static/js/webgl/models/brain/brain.glb',
			( gltf ) => {
				model = gltf.scene;
				model.traverse( function ( object ) {
					if ( object.isMesh ) {
						if(object.userData.name !== 'brain-wireframe'){
							let mesh = new THREE.Mesh(object.geometry, raycastedMesh);
							mesh.name = object.userData.name;
							raycastMeshes.push(mesh);
						}
						if(object.userData.name == 'brain-wireframe'){
							let edgesGeo = new THREE.EdgesGeometry( object.geometry); 
							let edgesMat = new THREE.LineBasicMaterial( { color: 0x40e0d0, linewidth: 1, transparent: true, opacity: 0.4 } );
							let wireframeMesh = new THREE.LineSegments( edgesGeo, edgesMat );							
							scene.add( wireframeMesh );
						}
					}
				} );
			}
		);
		point = new THREE.Vector3(0,0,0);
		points = [point,point,point,point];
		lineGeo = new LineGeometry();
		lineSpline = new THREE.CatmullRomCurve3( points );
		lineSpline.curveType = 'chordal';
		
		lineGeo.setPositions( updateCurve(lineSpline, 180) );
		
		line = new THREE.LineSegments( lineGeo, matLine );
		line.computeLineDistances();
		line.geometry._maxInstanceCount = 0;
		//line.scale.set( 1, 1, 1 );
		scene.add( line );

		let sphereGeo = new THREE.SphereGeometry( 0.01 );
		let sphereMat = new THREE.MeshBasicMaterial( { color: 0x40e0d0, transparent: true, opacity: 0, fog: false } );
		curveSrc = new THREE.Mesh( sphereGeo, sphereMat );
		scene.add( curveSrc );
		const element = document.createElement( 'div' );
		element.className = 'element';
		element.style.backgroundColor = 'rgba(0,127,127,0.25)';
		const topic = document.createElement( 'div' );
		topic.className = 'topic';
		element.appendChild( topic );
		const details = document.createElement( 'div' );
		details.className = 'details';
		element.appendChild( details );
		objectCSS = new CSS3DObject( element );
		objectCSS.scale.x = objectCSS.scale.y = objectCSS.scale.z = 0.001;
		objectCSS.element.style.opacity = 0;
		scene.add( objectCSS );
	}
	function updateCurve(lineSpline, divisions){
		let linePoints = [];
		for ( let i = 0; i < divisions; i ++ ) {
			const t = i / divisions;
			lineSpline.getPoint( t, point );
			linePoints.push( Math.trunc(point.x*10000)/10000,  Math.trunc(point.y*10000)/10000,  Math.trunc(point.z*10000)/10000 );
		}
		return linePoints;
	}

	function render(){
		scene.raf.currFrame++;
		matLine.resolution.set( window.innerWidth, window.innerHeight );
		xPos = camera.position.x;
		yPos = camera.position.y;
		zPos = camera.position.z;
		midHeadPos.set(xPos/8, yPos*1.2, zPos/10);
		midTailPos.set( xPos/3, yPos/3, zPos/4 );
		tailPos.set(xPos/2, yPos/2, zPos/2 );

		objectCSS.position.copy( tailPos );
		objectCSS.rotation.x = camera.rotation.x;
		objectCSS.rotation.y = camera.rotation.y;
		objectCSS.rotation.z = camera.rotation.z;
		
		lineSpline.points = [ headPos, midHeadPos, midTailPos, tailPos ];
		line.geometry.setPositions( updateCurve(lineSpline, 180) );
		
		
		pointIntersect = new THREE.Vector2( 0, yPos/4 );
		raycaster.setFromCamera( pointIntersect, camera );
		intersects = raycaster.intersectObjects( raycastMeshes, false );
		
		if ( intersects.length > 0 ) {
			//intersected
			let intersected = intersects[ 0 ];
			headPos	= intersected.point;
			curveSrc.position.copy( headPos);
			lineSpline.points = [ headPos, midHeadPos, midTailPos, tailPos ];
			let updatedCurve = updateCurve(lineSpline, 180);
			line.geometry.setPositions( updatedCurve );
			if(currentIntersected == null){
				currentIntersected = intersected;
				setCssElmInfo(currentIntersected.object);
				headPos	= intersected.point;
				curveSrc.position.copy( headPos );
				let animeArray = [];
				animeArray.push(
				
				animationItem(scene.raf.currFrame, curveSrc.material, 'opacity', 1, 1*scene.raf.fps, 0),
				animationItem(scene.raf.currFrame, line.geometry, '_maxInstanceCount', 179, 1*scene.raf.fps, 0, easeInOutQuad, function() { 
					line.geometry._maxInstanceCount = 179;
					let animeArray = [];
					animeArray.push(
						animationItem(scene.raf.currFrame, objectCSS.element.style, 'opacity', 1, 1*scene.raf.fps, 0)
					);
					animeArray.forEach((element) => renderGroup.push(element));
					})
				);
				animeArray.forEach((element) => renderGroup.push(element));
			}
			if(currentIntersected.object.name != intersected.object.name){
				currentIntersected = intersected;
				let animeArray = [];
				animeArray.push(
					animationItem(scene.raf.currFrame, objectCSS.element.style, 'opacity', 0, 1*scene.raf.fps, 0, easeInOutQuad, function() { 
						setCssElmInfo(currentIntersected.object);
						let animeArray = [];
						animeArray.push(
							animationItem(scene.raf.currFrame, objectCSS.element.style, 'opacity', 1, 1*scene.raf.fps, 0)
						)
						animeArray.forEach((element) => renderGroup.push(element));
					})
				);
				animeArray.forEach((element) => renderGroup.push(element));
			}
			if(currentIntersected.object.name == intersected.object.name){
				//lineGeo.setPositions( updateCurve(lineSpline) );
			}
		}
		if ( intersects.length == 0 ) {
			if(currentIntersected != null){
				let animeArray = [];
				animeArray.push(
					
					animationItem(scene.raf.currFrame, line.geometry, '_maxInstanceCount', 0, 1*scene.raf.fps, 0),
					animationItem(scene.raf.currFrame, curveSrc.material, 'opacity', 0, 1*scene.raf.fps, 0),
					animationItem(scene.raf.currFrame, objectCSS.element.style, 'opacity', 0, 1*scene.raf.fps, 0, easeInOutQuad, function() {
						currentIntersected = null;
					})
				);
				animeArray.forEach((element) => renderGroup.push(element));
			}
		}

		if(renderGroup.length > 0){	
			for(let i = 0; i < renderGroup.length; i++){
				// [ startFrame, endFrame, item, property, ease, startV, deltaV, endV, endAction ]
				scene.raf.motionCount = scene.raf.currFrame - renderGroup[i][0];
				if(scene.raf.motionCount < renderGroup[i][1]){
					renderGroup[i][2][renderGroup[i][3] ] = Math.abs( renderGroup[i][5] - Math.trunc(renderGroup[i][4](scene.raf.motionCount, renderGroup[i][5], renderGroup[i][6], renderGroup[i][1])*1000 )/1000 );
				}
				if(scene.raf.motionCount >= renderGroup[i][1]){
					renderGroup[i][2][renderGroup[i][3] ] = renderGroup[i][7];
					if(renderGroup[i][8]){
						renderGroup[i][8]();
					}
					renderGroup.splice(i, 1);
				}						
			}
		}
		renderer.render( scene, camera );
		cssRenderer.render( scene, camera );
		controls.update();
	}
	function setCssElmInfo(currentIntersected){
		let elementByName = document.getElementById(currentIntersected.name);
		objectCSS.element.children[0].textContent = elementByName.children[0].textContent;
		objectCSS.element.children[1].textContent = elementByName.children[1].textContent;
	}
	function setmotionIdle(bool){
		motionIdle = bool;
	}
	function onWindowResize(){
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
		cssRenderer.setSize( window.innerWidth, window.innerHeight );
	}
	function animate(){	
		scene.raf.fpsInterval = scene.raf.currT - scene.raf.prevT;
		if(scene.raf.fpsInterval > scene.raf.fpsD){
			scene.raf.prevT = scene.raf.currT;
			render(scene.renderGroup);
		}
		scene.raf.currT += scene.raf.fps;
		requestAnimationFrame(animate);
	}
	function animationItem(currentFrame, item, property, endV, endFrame, delayFrame, ease=easeInOutQuad, endAction=null){
		let startV = item[property];
		let deltaV = Math.abs(endV - startV);
		return [ currentFrame, endFrame + delayFrame, item, property, ease, startV, deltaV, endV, endAction ]
	}
	function easeInOutQuad(t, b, c, d) {
		if ((t /= d / 2) < 1) return c / 2 * t * t + b;
		return -c / 2 * ((--t) * (t - 2) - 1) + b;
	}
</script>
	</body>
</html>
